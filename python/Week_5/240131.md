# 배열
### 2차원 배열
1차원 리스트를 묶어놓은 리스트이다.

2차원 이상의 다차원 리스트는 차원에 따라 인덱스를 선언하며, 2차원 리스트는 세로길이(행의 개수)와 가로길이(열의 개수)를 필요로 한다.

> #### 참고
```py
"""
3
1 2 3
4 5 6
7 8 9
"""
N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]  # [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```
```py
"""
3
123
456
789
"""
N = int(input())
arr = [list(map(int, input())) for _ in range(N)]  # [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```
```

> #### 2차원 리스트 선언
2차원 리스트 선언시 얕은 복사에 주의하여 선언한다.
```py
arr1 = [[0] * 3 for _ in range(3)]
arr1[0][0] = 1  # [[1, 0, 0], [0, 0, 0], [0, 0, 0]
```
```py
arr2 = [[0] * 3] * 3
arr2[0][0] = 1  # [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
```

### 배열 순회
$n\times m$ 배열의 $mn$ 개의 모든 원소를 빠짐없이 조사하는 방법이다.

#### 행 우선 순회
![](https://velog.velcdn.com/images/pyoung/post/fef52c90-3b04-4cd4-9280-5bace34f06fb/image.png)

```py
for i in range(N):
	for j in range(M):
		f(array[i][j])
```

#### 열 우선 순회
![](https://velog.velcdn.com/images/pyoung/post/5a0cd7f5-e539-420c-824a-319ac391e72c/image.png)
```py
for j in range(M):
	for i in range(N):
		f(array[i][j])
```

#### 지그재그 순회
![](https://velog.velcdn.com/images/pyoung/post/058c3100-4c92-4aad-8575-38f6b169ccc9/image.png)
```py
for i in range(N):
	for j in range(M):
		f(array[i][j + (M - 1 - 2 * j) * (i % 2)])
```

> 지그재그 순회는 `i % 2`을 통해 방향을 조절할 수 있다.

#### 델타를 이용한 2차 배열 탐색
2차원 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법이다. 인덱스 `(i, j)`인 칸의 상하좌우 칸 `(ni, nj)`을 탐색한다.
![](https://velog.velcdn.com/images/pyoung/post/65df6207-0509-401f-a829-30b0e719e8b7/image.png)
```py
delta = [(0, 1), (1, 0), (0, -1), (-1, 0)]

for i in range(N):
	for j in range(N):
    	for di, dj in delta:
        	ni = i + di
            nj = j + dj
            if 0 <= ni < N and 0 <= nj < N:
            	f(array[ni][nj])
```

#### 전치 행렬
```py
for i in range(N):
	for j in range(N):
    	if i < j:
        	arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
```
`for` 문을 활용하지 않고 `zip` 함수를 사용하면 좀 더 간단하게 구현할 수 있다.
```py
arr = list(zip(*arr))
```

# 부분집합 합 문제
유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제이다.

### 완전탐색
완전검색 기법으로 부분집합 합 문제를 풀기 위해서는, 우선 모든 집합의 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산해야 한다.

집합의 원소가 $n$개일 때, 부분집합의 수는 $2^n$개이다. 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같다.
```py
bit = [0, 0, 0, 0]
for i in range(2):
	bit[0] = i  # 0번 원소
    for j in range(2):
    	bit[1] = j  # 1번 원소
        for k in range(2):
        	bit[2] = k  # 2번 원소
            for l in range(2):
            	bit[3] = l  # 3번 원소
                print(sum(bit))
```

> 원소의 개수가 늘어남에 따라 `for` 문이 기하급수적으로 늘어난다.

### 비트 연산자
- `&` : 비트 단위로 AND 연산을 한다.
- `|` : 비트 단위로 OR 연산을 한다.
- `<<` : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
- `>>` : 피연산자의 비트 열을 오른쪽으로 이동시킨다.
- `1 << n` : $2^n$, 즉 원소가 $n$개일 경우의 모든 부분집합의 수를 의미한다.
- `i & (1 << j)` : `i`의 `j`번째 비트가 1인지 아닌지를 검사한다.

```py
arr = [3, 6, 7]
n = len(arr)

total_lst = []
for i in range(1 << n):
	sub_lst = []
    for j in range(n):
    	if i & (1 << j):
        	sub_lst.append(arr[j])
	total_lst.append(sub_lst)
print(total_lst)  # [[], [3], [6], [3, 6], [7], [3, 7], [6, 7], [3, 6, 7]]
```

#### 비트 연산자를 이용한 부분집합
서로 다른 모든 자연수는 각각 서로 다른 비트 열(이진수)를 갖는다. 예를 들어 $0$부터 $7(=2^3 - 1)$까지의 숫자는 다음과 같이 서로 다른 비트 열을 갖는다.

|자연수|비트열|
|:---:|:---:|
|$0$|$0_{(2)}$|
|$1$|$1_{(2)}$|
|$2$|$10_{(2)}$|
|$3$|$11_{(2)}$|
|$4$|$100_{(2)}$|
|$5$|$101_{(2)}$|
|$6$|$110_{(2)}$|
|$7$|$111_{(2)}$|

즉, <span style="color: red;">$2^n - 1$까지의 서로 다른 비트 열은 $n$자리로 만들 수 있는 비트 열의 모든 조합</span>이다. <span style="color: red;">비트 열의 조합을 배열의 인덱스로 사용</span>하여 부분집합을 구하는 것이 주요 아이디어이다.

1. `1 << n`의 의미는 `1`의 비트 열을 왼쪽으로 `n`만큼 이동시킨다는 뜻이다. 위의 코드와 같이 `n = 3`의 경우 `1`의 비트열 $1_{(2)}$을 3만큼 왼쪽으로 이동시키면 $100_{2} = 2^3$이 되며, 이는 모든 부분집합의 수를 의미한다.
2. `i`는 `0`부터 `2**n - 1`까지 순회하며, $n$자리로 만들 수 있는 비트 열의 조합을 내포한다. 따라서 `j`는 `0`부터 `n - 1`까지 $n$번 순회하면서 <span style="color: red;">`i`의 비트 열에서 $1$이 어느 위치에 있는지 구하는 변수이다.</span>
3. 비트 열의 오른쪽부터 시작하며 $n$자리까지 조사한다. `1 << j`로 `1`의 비트 열을 왼쪽으로 `j`만큼 이동시킨 후, `i`의 비트 열과 AND 연산을 한다. 따라서 $1$이 어느 위치에 있는지 알 수 있다.
4. 이 <span style="color: red;">위치를 배열의 인덱스로 설정</span>하여 `sub_lst`에 담아 최종적으로 `total_lst`에 담는다.

> #### `i & (1 << j)`
어떻게 `i`의 비트 열에서 $1$의 위치를 알 수 있을까? 위의 코드에서 `i = 5`일 때를 생각한다.
`5`의 비트열은 $101_{(2)}$이며, $1$의 위치를 알아내기 위해 AND 연산자를 활용한다.
1. `j = 0` : $101_{(2)}$ & $001_{(2)}$의 값은 1이므로 `0`을 인덱스로써 사용한다.
2. `j = 1` : $101_{(2)}$ & $010_{(2)}$의 값은 0이므로 `1`을 인덱스로써 사용하지 않는다.
3. `j = 2` : $101_{(2)}$ & $100_{(2)}$의 값은 1이므로 `2`을 인덱스로써 사용한다.
따라서 인덱스로써 사용할 수는 `0`과 `1`이며, 이를 배열 `arr`에서 접근한다.