> #### 용어
**라이브러리** : 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것을 의미한다. 프레임워크에 비해 자유롭다.
**프레임워크** : 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것을 의미한다. 폴더명, 파일명 등에 대한 규칙이 있으며 라이브러리에 비해 좀 더 엄격하다.

***

# 디자인 패턴
디자인 패턴이란 프로그램을 설계할 때 발생했던 문제점들을 해결할 수 있도록 하나의 ‘규약’ 형태로 만들어 놓은 것을 의미한다.

***

# 싱글톤 패턴
싱글톤 패턴(singleton pattern)은 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴이다. 보통 데이터베이스 연결 모듈에 사용된다.

하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 인스턴스를 생성할 때 드는 비용이 줄어드는 장점이 있다. 하지만 의존성이 높아진다는 단점이 있다.

### 싱글톤 패턴의 단점
싱글톤 패턴은 TDD(Test Driven Development)를 할 때 걸림돌이 된다. TDD를 할 때 단위 테스트를 하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며 어떤 순서로든 실행할 수 있어야 한다.

하지만 싱글톤 패턴은 각 테스트마다 ‘독립적인’ 인스턴스를 만들기 어렵다.

> #### TDD(Test Driven Development)
테스트 주도 개발. 작은 단위의 테스트를 작성하고 반복적으로 코드를 추가하여 개발하는 방식이다.

### 의존성 주입
싱글톤 패턴은 모듈 간의 결합을 강하게 만들 수 있다는 단점이 있다. 이때 의존성 주입(DI, Dependency Injection)을 통해 모듈 간의 결합을 조금 더 느슨하게 만들어 해결할 수 있다.

![](https://velog.velcdn.com/images/pyoung/post/7ca8106f-e760-4941-b20a-43bff7b424e4/image.png)
중간에 의존성 주입자(dependency injector)를 통해 메인 모듈(main module)이 ‘간접’적으로 하위 모듈에 의존성을 주입하는 방식이다.

#### 의존성 주입의 장점
모듈들을 쉽게 교체할 수 있는 구조가 되어 테스팅하기 쉽고 마이그레이션하기도 수월하다. 또한 애플리케이션 의존성 방향이 일관되고, 애플리케이션을 쉽게 추론할 수 있으며, 모듈 간의 관계들이 명확해진다.

#### 의존성 주입의 단점
모듈들이 분리되므로 복잡성이 증가될 수 있으며 런타임 페널티가 생기기도 한다.

#### 의존성 주입 원칙
상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 한다. 또한 추상화는 세부 사항에 의존하지 않아야 한다.

***

# 팩토리 패턴
팩토리 패턴(factory pattern)은 객체 생성 부분을 제외한 추상화 패턴으로, 상위 클래스가 중요한 뼈대를 결정하고 하위 클래스가 객체 생성에 관한 구체적인 내용을 결정하는 패턴이다.

상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가지며 더 많은 유연성을 가진다. 또한 유지 보수성이 증가한다.

***

# 전략 패턴
전략 패턴(strategy pattern)은 객체의 행위를 바꾸고 싶은 경우 ‘캡슐화한 알고리즘’을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴이다.
![](https://velog.velcdn.com/images/pyoung/post/9d9da167-60d9-4a11-b23e-58f338750863/image.png)

> #### 용어
**컨텍스트** : 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보이다.

### passport의 전략 패턴
passport는 전략 패턴을 활용한 라이브러리이다. Node.js에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리로, 여러 가지 ‘전략’을 기반으로 인증할 수 있게 한다.

> #### 용어
**미들웨어** : 양 쪽을 연결하여 데이터를 주고 받을 수 있도록 중간에서 매개 역할을 하는 소프트웨어이다.

***

# 옵저버 패턴
옵저버 패턴(observer pattern)은 주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 옵저버들에게 변화를 알려주는 디자인 패턴이다.

주체란 객체의 상태 변화를 보고 있는 관찰자이며, 옵저버들이란 ‘추가 변화 사항’이 생기는 객체들을 의미한다.
![](https://velog.velcdn.com/images/pyoung/post/ab035259-5c9a-4619-a240-85a5d5bd7c30/image.png)

![](https://velog.velcdn.com/images/pyoung/post/23410980-ae9a-4e73-93a0-432e26f440cd/image.png)

![](https://velog.velcdn.com/images/pyoung/post/bd457b42-321d-406c-882b-af7034f9e2bc/image.png)

옵저버 패턴은 주로 이벤트 기반 시스템에 사용하며 MVC(Model-View-Controller) 패턴에도 사용된다.

### 자바: 상속과 구현
#### 상속
상속(extends)은 자식 클래스가 부모 클래스의 메서드 등을 상속받아 사용하며 추가 및 확장할 수 있는 것을 말한다. 재사용성, 중복성의 최소화가 이루어진다.

#### 구현
구현(implements)은 부모 인터페이스(interface)를 자식 클래스에서 재정의하여 구현하는 것을 말한다. 상속과는 달리 반드시 부모 클래스의 메서드를 재정의하여 구현해야 한다.

#### 상속과 구현의 차이점
상속은 일반 클래스, `abstract` 클래스를 기반으로 구현하며, 구현은 인터페이스를 기반으로 구현한다.

> #### 용어
**인터페이스** : 일종의 추상 클래스로, 추상 메서드를 갖지만 추상 클래스보다 추상화 정도가 높다.

### 자바스크립트에서의 옵저버 패턴
#### 프록시 객체
프록시(proxy) 객체는 어떠한 대상의 기본적인 동작의 작업을 가로챌 수 있는 객체를 의미한다.
- `target` : 프록시할 대상.
- `handler` : `target` 동작을 가로채고 어떠한 동작을 할 것인지가 설정되어 있는 함수.

### Vue.js 3.0의 옵저버 패턴
`ref`나 `reactive`로 정의하면 해당 값이 변경되었을 때 자동으로 DOM에 있는 값이 변경된다. 이는 프록시 객체를 이용한 프록시 패턴을 이용하여 구현한 것이다.

> #### 용어
**DOM(Document Object Model)** : 문서 객체 모델을 말하며, 웹 브라우저상의 화면을 이루고 있는 요소들을 지칭한다.

***

# 프록시 패턴과 프록시 서버
### 프록시 패턴
프록시 패턴(proxy pattern)은 대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 해당 접근을 필터링하거나 수정하는 등의 역할을 하는 계층이 있는 디자인 패턴이다.
![](https://velog.velcdn.com/images/pyoung/post/344bc5cb-f834-476b-a264-8795c09d2aa3/image.png)

이를 통해 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용한다.

> #### 용어
**프록시 서버에서의 캐싱** : 캐시 안에 정보를 담아두고, 캐시 안에 있는 데이터를 활용하는 것을 말한다. 이를 통해 불필요하게 외부와 연결하지 않기 때문에 트래픽을 줄일 수 있다.

### 프록시 서버
프록시 서버(proxy server)는 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 말한다.

#### 프록시 서버로 쓰는 nginx
nginx는 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버이다. 주로 Node.js 서버 앞단의 프록시 서버로 활용된다.
![](https://velog.velcdn.com/images/pyoung/post/246f4f5b-5f38-4ef4-a8b2-55db28c70a73/image.png)

nginx를 프록시 서버로 둬서 실제 포트를 숨길 수 있고 정적 자원을 gzip 압축하거나, 메인 서버 앞단에서의 로깅을 할 수 있다.

> #### 용어
**버퍼 오버플로우** : 버퍼는 데이터가 저장되는 메모리 공간으로, 메모리 공간을 벗어나는 경우를 말한다.
**로깅** : 로그(log)를 생성하도록 시스템을 작성하는 활동을 말한다.

#### 프록시 서버로 쓰는 CloudFlare
CloudFlare는 전 세계적으로 분산된 서버가 있고 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스이다.

CloudFlare는 웹 서버 앞단에 프록시 서버로 두어 DDOS 공격 방어나 HTTPS 구축에 쓰인다.
![](https://velog.velcdn.com/images/pyoung/post/5692c5b8-282e-4b9a-96b3-0627c85a7823/image.png)

#### DDOS 공격 방어
DDOS는 짧은 기간 동안 네트워크에 많은 요청을 보내 네트워크를 마비시켜 웹 사이트의 가용성을 방해하는 사이버 공격 유형이다.

#### HTTPS 구축
CloudFlare를 사용하면 별도의 인증서 설치 없이 손쉽게 HTTPS를 구축할 수 있다.

> #### 용어
**CDN(Content Delivery Network)** : 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크를 말한다.

#### CORS와 프런트엔드의 프록시 서버
CORS(Cross-Origin Resource Sharing)는 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘이다.
![](https://velog.velcdn.com/images/pyoung/post/1704e032-9fa6-45f6-aded-3c090ad0aaaa/image.png)

프런트엔드 서버를 만들어서 백엔드 서버와 통신할 때 주로 CORS 에러를 마주치는데, 이를 해결하기 위해 프록시 서버를 만든다.

> #### 용어
**오리진** : 프로토콜과 호스트 이름, 포트의 조합을 말한다.

프록시 서버를 둬서 프런트엔드 서버에서 요청되는 오리진을 바꾼다.
![](https://velog.velcdn.com/images/pyoung/post/be670863-dd12-46bf-a51e-eab86a8fe48a/image.png)

> #### 용어
**루프백 IP** : `127.0.0.1` 또는 `localhost`. 본인 PC 서버의 IP를 의미하며, DNS를 거치지 않고 본인 PC 버서로 연결된다.

***

# 이터레이터 패턴
이터레이터 패턴(iterator pattern)은 이터레이터(iterator)를 사용하여 컬렉션(collection)의 요소들에 접근하는 디자인 패턴이다.

> #### 용어
**이터레이터 프로토콜** : 이터러블한 객체들을 순회할 때 쓰이는 규칙이다.
**이터러블한 객체** : 반복 가능한 객체로 배열을 일반화한 객체이다.

***

# 노출모듈 패턴
노출모듈 패턴(revealing module pattern)은 즉시 실행 함수를 통해 `private`, `public` 같은 접근 제어자를 만드는 패턴을 말한다.

> #### 용어
**`public`** : 클래스에 정의된 함수, 자식 클래스, 외부 클래스에서 접근 가능한 범위를 말한다.
**`protected`** : 클래스에 정의된 함수, 자식 클래스에서 접근 가능한 범위를 말한다.
**`private`** : 클래스에 정의된 함수에서 접근 가능한 범위를 말한다.
**즉시 실행 함수** : 함수를 정의하자마자 바로 호출하는 함수이다.

***

# MVC
MVC는 모델(model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴이다. MVC 패턴의 대표적인 프레임워크로는 스프링(Spring)이 있다.

![](https://velog.velcdn.com/images/pyoung/post/7ee80e41-fc44-4c69-b10c-731423f7d9de/image.png)

애플리케이션의 구성 요소를 세 가지 역할로 구분하여, 각각의 구성 요소에만 집중해서 개발할 수 있다. 재사용성과 확장성이 용이하다는 장점이 있다.

### 모델
모델(model)은 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻한다.

### 뷰
뷰(view)는 사용자 인터페이스 요소를 나타낸다. 즉, 모델을 기반으로 사용자가 볼 수 있는 화면을 뜻한다. 또한, 변경이 일어나면 컨트롤러에 이를 전달해야 한다.

### 컨트롤러
컨트롤러(controller)는 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당한다.

> #### MTV 패턴
Django에서는 MTV 패턴을 사용하며, MVC와 같은 기능을 한다. MVC의 View가 MTV에서는 Template, Controller가 View를 의미한다.

***

# MVP
MVP 패턴은 MVC에서 C에 해당하는 컨트롤러가 프레젠터(presenter)로 교체된 패턴이다.
![](https://velog.velcdn.com/images/pyoung/post/4bc672db-2467-4a25-a4ee-e977e287a745/image.png)

뷰와 프레젠터는 일대일 관계이기 때문에 MVC 패턴보다 더 강한 결합을 지닌 디자인 패턴이다.

***

# MVVM 패턴
MVVM 패턴은 MVC의 C에 해당하는 컨트롤러가 뷰모델(view model)로 바뀐 패턴이다.
![](https://velog.velcdn.com/images/pyoung/post/a339b3d0-feff-498a-b69e-d1e772516d38/image.png)

MVVM 패턴은 커맨드와 데이터 바인딩을 가진다. 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다.

### MVMM 패턴의 Vue
Vue.js는 반응형이 특징인 MVMM 패턴의 프레임워크이다. `watch`나 `computed` 등으로 반응형적인 값들을 구축할 수 있다.

값 대입만으로도 변수가 변경되며 양방향 바인딩, html을 토대로 컴포넌트를 구축할 수 있다는 점이 특징이다.

> #### 용어
**커맨드** : 여러 가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법이다.
**데이터 바인딩** : 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법이다. 뷰모델을 변경하면 뷰가 변경된다.